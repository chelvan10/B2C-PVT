// AUTOGENERATED: Base Page Object - Production Ready - 2025-01-05
import { type Page, type Locator, expect } from '@playwright/test';

export abstract class BasePage {
  readonly page: Page;
  readonly baseUrl: string;

  constructor(page: Page, baseUrl: string = 'https://www.mitre10.co.nz') {
    this.page = page;
    this.baseUrl = baseUrl;
  }

  // Universal self-healing element finder
  protected async findElement(selectors: string[], timeout: number = 5000): Promise<Locator> {
    for (const selector of selectors) {
      try {
        const element = this.page.locator(selector);
        await element.waitFor({ timeout: Math.min(timeout / selectors.length, 2000) });
        if (await element.isVisible()) {
          return element;
        }
      } catch (error) {
        continue;
      }
    }
    throw new Error(`Element not found with any selector: ${selectors.join(', ')}`);
  }

  // Smart navigation with performance tracking
  async navigateTo(path: string): Promise<void> {
    const startTime = Date.now();
    
    try {
      await this.page.goto(`${this.baseUrl}${path}`);
      await this.page.waitForLoadState('domcontentloaded');
      
      const loadTime = Date.now() - startTime;
      console.log(`‚úÖ Navigation to ${path}: ${loadTime}ms`);
      
      if (loadTime > 5000) {
        console.log(`‚ö†Ô∏è Slow navigation detected: ${loadTime}ms`);
      }
    } catch (error) {
      console.log(`‚ùå Navigation failed: ${error}`);
      throw error;
    }
  }

  // Smart waiting with multiple strategies
  async waitForStability(): Promise<void> {
    const strategies = [
      () => this.page.waitForLoadState('networkidle', { timeout: 5000 }),
      () => this.page.waitForLoadState('domcontentloaded', { timeout: 3000 }),
      () => this.page.waitForTimeout(2000)
    ];

    for (const strategy of strategies) {
      try {
        await strategy();
        return;
      } catch (error) {
        continue;
      }
    }
  }

  // Universal content validation
  async validatePageContent(expectedElements: string[]): Promise<boolean> {
    let foundCount = 0;
    
    for (const element of expectedElements) {
      const selectors = [
        `[data-testid="${element}"]`,
        `text=/${element}/i`,
        `.${element.replace(/\s+/g, '-')}`,
        `[aria-label*="${element}" i]`
      ];
      
      try {
        await this.findElement(selectors, 2000);
        foundCount++;
      } catch (error) {
        continue;
      }
    }
    
    const successRate = (foundCount / expectedElements.length) * 100;
    console.log(`‚úÖ Page validation: ${foundCount}/${expectedElements.length} elements found (${successRate.toFixed(1)}%)`);
    
    return foundCount >= Math.ceil(expectedElements.length * 0.6); // 60% threshold
  }

  // Smart screenshot capture for key steps
  async captureStep(stepName: string): Promise<void> {
    try {
      await this.page.screenshot({
        path: `test-results/steps/${stepName}-${Date.now()}.png`,
        fullPage: false
      });
      console.log(`üì∏ Step captured: ${stepName}`);
    } catch (error) {
      console.log(`‚ö†Ô∏è Screenshot failed: ${error}`);
    }
  }

  // Performance monitoring
  async measurePerformance(action: () => Promise<void>, actionName: string): Promise<number> {
    const startTime = Date.now();
    await action();
    const duration = Date.now() - startTime;
    
    console.log(`‚ö° ${actionName}: ${duration}ms`);
    return duration;
  }
}