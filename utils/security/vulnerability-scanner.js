/**
 * ENTERPRISE VULNERABILITY SCANNER
 * Scans only source code, excludes auto-generated files
 */

const fs = require('fs').promises;
const path = require('path');

class VulnerabilityScanner {
  constructor() {
    this.excludePaths = [
      'node_modules',
      'playwright-report',
      'config/playwright-report',
      'test-results',
      '.git'
    ];
  }

  async scanSourceCode() {
    const results = {
      clean: true,
      issues: [],
      scannedFiles: 0
    };

    await this.scanDirectory('/home/ari/B2C PVT Demo', results);
    return results;
  }

  async scanDirectory(dir, results) {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (this.shouldExclude(fullPath)) continue;
        
        if (entry.isDirectory()) {
          await this.scanDirectory(fullPath, results);
        } else if (this.isSourceFile(entry.name)) {
          await this.scanFile(fullPath, results);
        }
      }
    } catch (error) {
      // Skip inaccessible directories
    }
  }

  shouldExclude(filePath) {
    return this.excludePaths.some(exclude => 
      filePath.includes(exclude) || filePath.includes(`/${exclude}/`)
    );
  }

  isSourceFile(filename) {
    return /\.(js|ts|jsx|tsx)$/.test(filename) && 
           !filename.includes('.min.') &&
           !filename.includes('.bundle.');
  }

  async scanFile(filePath, results) {
    try {
      const content = await fs.readFile(filePath, 'utf8');
      results.scannedFiles++;
      
      // Only scan for actual hardcoded credentials in source code
      const credentialPattern = /(password|secret|key|token)\s*[:=]\s*["'][a-zA-Z0-9]{8,}["']/i;
      if (credentialPattern.test(content) && 
          !content.includes('process.env') && 
          !content.includes('CHANGE_ME')) {
        results.clean = false;
        results.issues.push({
          file: filePath,
          type: 'hardcoded-credential',
          severity: 'high'
        });
      }
    } catch (error) {
      // Skip unreadable files
    }
  }
}

module.exports = VulnerabilityScanner;