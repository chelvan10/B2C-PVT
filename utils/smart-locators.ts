// AUTOGENERATED: Smart Locator Utilities - Production Ready - 2025-01-05
import { type Page, type Locator } from '@playwright/test';

export class SmartLocators {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  // Universal element finder with priority-based strategies
  async findElement(config: {
    testId?: string;
    role?: { name: string; type?: string };
    text?: string | RegExp;
    css?: string[];
    fallback?: string[];
  }): Promise<Locator> {
    
    const strategies: (() => Locator)[] = [];

    // Priority 1: Test ID (most reliable)
    if (config.testId) {
      strategies.push(() => this.page.getByTestId(config.testId!));
    }

    // Priority 2: Role-based (semantic)
    if (config.role) {
      strategies.push(() => this.page.getByRole(config.role!.type as any || 'button', { name: config.role!.name }));
    }

    // Priority 3: Text-based (user-facing)
    if (config.text) {
      strategies.push(() => this.page.getByText(config.text!));
    }

    // Priority 4: CSS selectors (structural)
    if (config.css) {
      config.css.forEach(selector => {
        strategies.push(() => this.page.locator(selector));
      });
    }

    // Priority 5: Fallback selectors
    if (config.fallback) {
      config.fallback.forEach(selector => {
        strategies.push(() => this.page.locator(selector));
      });
    }

    // Try each strategy
    for (const strategy of strategies) {
      try {
        const element = strategy();
        if (await element.isVisible({ timeout: 2000 })) {
          return element;
        }
      } catch (error) {
        continue;
      }
    }

    throw new Error(`Element not found with config: ${JSON.stringify(config)}`);
  }

  // Smart form interaction
  async fillForm(fields: Array<{
    name: string;
    value: string;
    type?: 'input' | 'select' | 'textarea';
  }>): Promise<void> {
    
    for (const field of fields) {
      try {
        const element = await this.findElement({
          testId: field.name,
          css: [
            `input[name="${field.name}"]`,
            `#${field.name}`,
            `[data-testid="${field.name}"]`
          ],
          fallback: [
            `input[placeholder*="${field.name}" i]`,
            `label:has-text("${field.name}") + input`
          ]
        });

        await element.clear();
        await element.fill(field.value);
        console.log(`✅ Filled ${field.name}: ${field.value}`);
        
      } catch (error) {
        console.log(`⚠️ Failed to fill ${field.name}: ${error}`);
        throw error;
      }
    }
  }

  // Smart navigation with multiple strategies
  async navigateToSection(sectionName: string, fallbackUrl?: string): Promise<boolean> {
    const strategies = [
      // Strategy 1: Direct URL
      async () => {
        if (fallbackUrl) {
          await this.page.goto(fallbackUrl);
          return true;
        }
        return false;
      },
      
      // Strategy 2: Navigation link
      async () => {
        const element = await this.findElement({
          testId: sectionName.toLowerCase().replace(/\s+/g, '-'),
          role: { name: sectionName, type: 'link' },
          text: new RegExp(sectionName, 'i'),
          css: [`a[href*="${sectionName.toLowerCase()}"]`]
        });
        
        await element.click();
        return true;
      }
    ];

    for (const strategy of strategies) {
      try {
        if (await strategy()) {
          await this.page.waitForLoadState('domcontentloaded');
          console.log(`✅ Navigated to ${sectionName}`);
          return true;
        }
      } catch (error) {
        continue;
      }
    }

    console.log(`⚠️ Could not navigate to ${sectionName}`);
    return false;
  }

  // Smart content validation
  async validateContent(expectedElements: string[]): Promise<{
    found: string[];
    missing: string[];
    successRate: number;
  }> {
    
    const found: string[] = [];
    const missing: string[] = [];

    for (const element of expectedElements) {
      try {
        await this.findElement({
          testId: element.toLowerCase().replace(/\s+/g, '-'),
          text: new RegExp(element, 'i'),
          css: [
            `.${element.toLowerCase().replace(/\s+/g, '-')}`,
            `[class*="${element.toLowerCase()}"]`
          ]
        });
        
        found.push(element);
      } catch (error) {
        missing.push(element);
      }
    }

    const successRate = (found.length / expectedElements.length) * 100;
    
    return {
      found,
      missing,
      successRate
    };
  }
}